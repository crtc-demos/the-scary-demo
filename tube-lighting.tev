#stage 0:
#  cr0.rgb = texmap0[texcoord0].rgb;

# texmap1 is ramp texture
#stage 1:
#  tev.rgb = texmap1[texcoord1].arr;

# texmap2 is shadow buffer
#stage 2:
#  tev.rgb = (tev{gr} > texmap2[texcoord2]{ra}) ? 1 : 0;

# lit colour
#stage 3:
#  cr2.rgb = clamp (chan0.aaa + cr0.rgb * chan0.rgb);

# in-shadow colour
#stage 4:
#  cr0.rgb = cr0.rgb * cr1.rgb;

#stage 5:
#  tev.rgb = mix (cr2.rgb, cr0.rgb, tev.rgb);

# shadow buffer sample 1
stage 0:
  tev.rgb = texmap2[texcoord2].arr;

# shadow buffer sample 2
stage 1:
  cr0.rgb = texmap2[texcoord3].arr;

# shadow buffer sample 3
stage 2:
  cr1.rgb = texmap2[texcoord4].arr;

# depth ramp lookup
stage 3:
  cr2.rgb = texmap1[texcoord1].arr;

stage 4:
  cr1.rgb = (cr2{gr} > cr1{gr}) ? 1 : 0;

stage 5:
  cr0.rgb = (cr2{gr} > cr0{gr}) ? 1 : 0;

stage 6:
  tev.rgb = (cr2{gr} > tev{gr}) ? 1 : 0;

stage 7:
  tev.rgb = clamp (tev.rgb * cr0.rgb);

# shadow (1) or lit (0)
stage 8:
  cr0.rgb = clamp (tev.rgb * cr1.rgb);

stage 9:
  tev.rgb = texmap0[texcoord0].rgb;

# lit colour
stage 10:
  cr1.rgb = clamp (chan0.aaa + tev.rgb * chan0.rgb);

# shadow colour
stage 11:
  tev.rgb = tev.rgb * k0.rgb;

stage 12:
  tev.rgb = mix (cr1.rgb, tev.rgb, cr0.rgb);
